#!/usr/bin/env rakudo

constant SCRIPT_VERSION = "dev";
constant DEFAULT_BUILDROOT = "{$*HOME}/Builds";

use lib $*PROGRAM.absolute.IO.parent(2).add("lib");

#| Print the application version and exit
multi MAIN(Bool :$version where *.so) {
    say SCRIPT_VERSION;
}

#| Create a buildroot and starter config
multi sub MAIN("setup", Str :$buildroot = DEFAULT_BUILDROOT #= Path of the directory where builds occur
) {
    run-command("setup", $buildroot.IO);
}

#| Install systemd services
multi sub MAIN("service", Str :$buildroot = DEFAULT_BUILDROOT) {
    run-command("service", $buildroot.IO);
}

#| Receive build requests over HTTP. Usually invoked via systemd socket service.
multi sub MAIN("bridge", Str :$buildroot = DEFAULT_BUILDROOT) {
    run-command("bridge", $buildroot.IO);
}

#| Start a build. Usually invoked via systemd path service.
multi sub MAIN("build", Str :$buildroot = DEFAULT_BUILDROOT) {
    run-command("build", $buildroot.IO);
}

#| Show the commands that would run during a build
multi sub MAIN("recipe", Str :$job #= Path of a job file
) {
    if $job.defined {
        run-command("recipe", $job.IO);
    } else {
        note $*USAGE;
        exit 2;
    }
}

sub run-command(Str $command, *@args) {
    require ::("Command::{$command.tc}");

    try {
        ::("Command::{$command.tc}::EXPORT::DEFAULT::&{$command.tc}")(|@args);

        CATCH {
            note "ERROR: " ~ .message;
            exit 3;
        }
    }
}

# Local Variables:
# mode: raku
# End:
